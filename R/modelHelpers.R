#### HELPERS
analysePositionInRanking <- function(model, alternative, rankType){
  assert(rankType %in% c("min", "max"), "rankType may be either min or max.")
  nrAlternatives <- nrow(model$preferencesToModelVariables)

  rankingAnalysisConstraints <-
    createConstraintsForExtremeRankAnalysis(model, alternative, rankType)

  #merge new constraints with the model's ones
  constraints <- model$constraints
  numberOfAdditionalColumns <- ncol(rankingAnalysisConstraints$lhs) - ncol(constraints$lhs)
  constraints$lhs <- cbind(constraints$lhs, matrix(0, nrow=nrow(constraints$lhs), ncol=numberOfAdditionalColumns))


  constraints <- combineConstraints(constraints, rankingAnalysisConstraints)

  startIndex <- ncol(constraints$lhs)-(nrAlternatives-1)
  objective <- rep(0, ncol(constraints$lhs))
  objective[startIndex:ncol(constraints$lhs)] <- 1
  objective[startIndex+alternative-1] <- 0
  stopIndex <- startIndex + nrAlternatives - 1

  solution <- extremizeVariable(objective, constraints, maximize=FALSE)
  if(validateSolution(solution, allowInconsistency = TRUE, minEpsilon = model$minEpsilon)){
    return(sum(solution$solution[startIndex:stopIndex]))
  }
  NULL
}

createConstraintsForExtremeRankAnalysis <- function(model, alternative, rankType){
  constraints <- list()
  nrAlternatives <- nrow(model$preferencesToModelVariables)
  modelsNumberOfVariables <- ncol(model$constraints$lhs)
  for(i in 1:nrAlternatives){
    if(i != alternative){

      lhs <- rep(0, modelsNumberOfVariables)
      bPositionInLHS <- 0

      if(rankType == "min"){
        # min
        utilityValuesDifference <- substractUtilityValuesOfAlternatives(alternativeIndex = alternative,
                                                                        referenceAlternativeIndex = i,
                                                                        model)


        # augment LHS to represent alternative's v_b
        lhs <- c(lhs, rep(0, nrAlternatives))
        bPositionInLHS <- modelsNumberOfVariables + i

        constraints.labels <- paste("extremeRank_v_>", alternative, ",", i, sep="")
      } else {
        # max
        utilityValuesDifference <- substractUtilityValuesOfAlternatives(alternativeIndex = i,
                                                                        referenceAlternativeIndex = alternative,
                                                                        model)
        # put U(a) - U(b) into the LHS
        lhs[1:length(utilityValuesDifference)] <- utilityValuesDifference

        lhs <- c(lhs, rep(0, nrAlternatives))
        bPositionInLHS <- modelsNumberOfVariables + i
        constraints.labels <- paste("extremeRank_v_<", alternative, ",", i, sep="")
      }

      lhs[1:length(utilityValuesDifference)] <- utilityValuesDifference
      lhs[bPositionInLHS] <- 1
      dir <- ">="
      rhs <- model$minEpsilon
      constraints <- combineConstraints(constraints, list(
        lhs = lhs,
        rhs = rhs,
        dir = dir,
        constraints.labels = constraints.labels
      ))
    }
  }

  variablesTypes <- c()
  newColnames <- paste("v_", rankType, "_", alternative, "_", 1:nrAlternatives, sep="")
  colnames(constraints$lhs) <- c(colnames(model$constraints$lhs), newColnames)
  variablesTypes <- rep("B", nrAlternatives)

  constraints$variablesTypes <- variablesTypes
  rownames(constraints$lhs) <- constraints$constraints.labels

  constraints
}

checkPreferenceRelationFeasibility <- function(model, alternative, referenceAlternative, relationType){
  assert(relationType %in% c("possible", "necessary"),
         "Only necessary and weak preference relations are possible")
  assert(!is.null(model$epsilonIndex), "Epsilon index must be included in a model")

  objective <- createObjective(model$constraints$lhs, model$epsilonIndex)

  constraints <- createModelForNecessaryAndPossibleRelationAnalysis(model, alternative, referenceAlternative, relationType)

  solution <- extremizeVariable(objective, constraints, maximize=TRUE)

  if(relationType == "necessary"){
    return(solution$status != 0 || solution$optimum < model$minEpsilon)
  } else if(relationType == "possible") {
    return(solution$status == 0 && solution$optimum >=model$minEpsilon)
  }
}

createModelForNecessaryAndPossibleRelationAnalysis <- function(model, alternative, referenceAlternative, relationType){
  constraints <- model$constraints

  constraints <- combineConstraints(constraints,
                                    buildPairwiseComparisonConstraint(alternative, referenceAlternative,
                                                                      model, preferenceType = relationType))
  constraints
}

createRankRelatedConstraints <- function(problem, model, minEpsilon, bigNumber=1e9){
  nrAlternatives <- nrow(problem$performanceTable)
  numberOfCriteria <- length(problem$criteria)
  numberOfDesiredRankConstraints <- nrow(problem$desiredRank)
  # number of constraints generated by the rank requirements, this +numberOfDesiredRankConstraints
  # stands for binary variables normalization (v_> + v_< <= 1)
  numberOfConstraints <- numberOfDesiredRankConstraints*( 3*(nrAlternatives - 1) + 2)
  # here we include binary variables that represents relations between the same alternative (v_{x,x})
  # they will be removed afterwards
  numberOfBinaryVariables <- 2*nrAlternatives*numberOfDesiredRankConstraints
  # needed to determine the number of the columns in the new lhs
  currentLHSColumnsNumber <- ncol(model$constraints$lhs)

  totalNumberOfColumnsInLHS <- numberOfBinaryVariables + ncol(model$constraints$lhs)

  # here we store indices that corresponds to the first binary variable associated with a corresponding alternative
  # to get an index of the first binary variable associated with a n-th alternative
  # use rankConstraintsFirstBinaryVariableIndices[n]
  # if returned value is NA there are no rank requirements related to the n'th alternative
  rankConstraintsFirstBinaryVariableIndices <- matrix(nrow=4)

  desiredRankConstraintsLHS <- c()
  desiredRankConstraintsRHS <- c()

  #constraints labels
  constraints.labels <- c()
  #variables labels
  variables.labels <- c()
  variables.labels <- c()
  for(alternative in problem$desiredRank[, 1]){
    for(referenceAlternative in seq(nrAlternatives))
    {
      variables.labels <- c(variables.labels, paste("v_", c(">_", "<_"), alternative, "_", referenceAlternative, sep=""))
    }
  }


  for(i in seq(numberOfDesiredRankConstraints))
  {
    alternative <- problem$desiredRank[i, 1]
    lowerPlace <- problem$desiredRank[i, 2]
    higherPlace <- problem$desiredRank[i, 3]

    rankConstraintsFirstBinaryVariableIndices[alternative] <- (i - 1)*2*nrAlternatives + 1
    # constraints:
    # U(a*) - U(b) + M*v >= epsilon for each b from A, which is not a
    # and
    # U(b) - U(a*) + M*v >= epsilon for each b from A, which is not a

    for(referenceAlternative in seq(nrAlternatives)){
      if(referenceAlternative != alternative)
      {
        for(type in c("lower", "upper"))
        {
          binaryVariablePosition <- (i - 1)*2*nrAlternatives +  ifelse(type == "lower",  2*referenceAlternative-1, 2*referenceAlternative)
          utilityValueDifference <- rep(0, currentLHSColumnsNumber)
          difference <- substractUtilityValuesOfAlternatives(alternative, referenceAlternative, model)
          # create a constraint row, difference can be a subvector if there were variables representing no characteristic points variables
          utilityValueDifference[1:length(difference)] <- difference
          # add epsilon
          utilityValueDifference[model$epsilonIndex] <- 1

          binaryVariables <- rep(0, numberOfBinaryVariables)
          binaryVariables[binaryVariablePosition] <- -bigNumber

          LHS <- c(utilityValueDifference, binaryVariables)
          desiredRankConstraintsLHS <- rbind(desiredRankConstraintsLHS, LHS)

          # RHS
          desiredRankConstraintsRHS <- c(desiredRankConstraintsRHS, 0)

          if(type == "lower"){
            constraints.labels <- c(constraints.labels, paste(alternative, "-", referenceAlternative))
          } else {
            constraints.labels <- c(constraints.labels, paste(referenceAlternative, "-", alternative))
          }
        }
        # sum of binary variables v_> + v_< <= 1 constraint
        activeBinaryVariables <- rep(0, numberOfBinaryVariables)
        pos <- (i - 1)*2*nrAlternatives + c(2*(referenceAlternative-1)+1, 2*(referenceAlternative-1)+2)
        activeBinaryVariables[pos] <- 1
        LHS <- c(rep(0, currentLHSColumnsNumber), activeBinaryVariables)
        desiredRankConstraintsLHS <- rbind(desiredRankConstraintsLHS, LHS)
        desiredRankConstraintsRHS <- c(desiredRankConstraintsRHS, 1)
        constraints.labels <- c(constraints.labels, paste("v_", alternative, "_",referenceAlternative,sep=""))
      }
    }
    # sum of binary variables constraints
    for(type in c("lower", "upper"))
    {
      # LHS
      sign <- ifelse(type == "lower", ">", "<")
      binaryVariables <- rep(0, numberOfBinaryVariables)
      startIndex <- (i - 1)*2*nrAlternatives + ifelse(type=="lower", 1, 2)
      indicesForSum <- seq(startIndex, startIndex + 2*nrAlternatives - 1, 2)
      binaryVariables[indicesForSum] <- 1
      LHS <- c(rep(0, currentLHSColumnsNumber), binaryVariables)
      desiredRankConstraintsLHS <- rbind(desiredRankConstraintsLHS, LHS)

      # RHS
      RHS <- ifelse(type=="lower", lowerPlace - 1, nrAlternatives - higherPlace)
      desiredRankConstraintsRHS <- c(desiredRankConstraintsRHS, RHS)

      constraints.labels <- c(constraints.labels, paste("sum_v_", sign, "a,b", sep = ""))
    }
  }
  # shift indices of first binary variables by the number of variables in the current lhs
  rankConstraintsFirstBinaryVariableIndices <- rankConstraintsFirstBinaryVariableIndices + currentLHSColumnsNumber

  # here we should combine constraints
  dir <- rep("<=", numberOfConstraints)
  variablesTypes <- c(rep("C", currentLHSColumnsNumber), rep("B", numberOfBinaryVariables))

  rownames(desiredRankConstraintsLHS) <- constraints.labels
  colnames(desiredRankConstraintsLHS) <- c(rep("-", ncol(model$constraints$lhs)), variables.labels)

  list(
    rankConstraintsFirstBinaryVariableIndices = rankConstraintsFirstBinaryVariableIndices,
    constraints = list(
      lhs = desiredRankConstraintsLHS,
      rhs = desiredRankConstraintsRHS,
      dir = dir,
      variablesTypes = variablesTypes,
      variables.labels = variables.labels,
      constraints.labels = constraints.labels
    )
  )
}

normalizationConstraint <- function(problem, numberOfVariables, numberOfCriteria){
  ## sum to 1
  lhs <- rep(0, numberOfVariables)

  for (j in seq_len(numberOfCriteria)) {
    if (problem$criteria[j] == 'g')
      lhs[problem$criteriaIndices[j] + problem$characteristicPoints[j] - 1] <- 1
    else
      lhs[problem$criteriaIndices[j]] <- 1
  }

  list(lhs = lhs,
       dir = "==",
       rhs = 1,
       constraints.labels = "norm")
}

leastValuableChPointsEqualZero <- function(problem, numberOfVariables, numberOfCriteria){
  constraints <- list()

  for(criterion in seq_len(numberOfCriteria)){
    lhs <- rep(0, numberOfVariables)
    chPointIndex <- ifelse(problem$criteria[criterion] == 'g',
                           problem$criteriaIndices[criterion],
                           problem$criteriaIndices[criterion] + problem$characteristicPoints[criterion] - 1)

    lhs[chPointIndex] <- 1
    rhs <- 0
    dir <- "=="
    constraints.labels <- paste("worstChPoint@",criterion,"=0", sep="")

    constraints <- combineConstraints(constraints,
                                      list(lhs = lhs,
                                           dir = dir,
                                           rhs = rhs,
                                           constraints.labels = constraints.labels))
  }
  constraints
}

# default epsilon value  = 1e-4
monotonicityConstraints <- function(problem, numberOfVariables, numberOfCriteria, rhoIndex, epsilon){
  ## monotonicity of vf
  constraints <- list()
  for (j in seq_len(numberOfCriteria)) {
    for (k in seq_len(problem$characteristicPoints[j] - 1)) {
      lhs <- rep(0, numberOfVariables)
      rhs <- 0

      if (problem$criteria[j] == "g") {
        lhs[problem$criteriaIndices[j] + k - 1] <- 1
        lhs[problem$criteriaIndices[j] + k] <- -1
      } else {
        lhs[problem$criteriaIndices[j] + k - 1] <- -1
        lhs[problem$criteriaIndices[j] + k] <- 1
      }

      if (problem$strictVF && !is.null(rhoIndex)) {
        lhs[rhoIndex] <- 1
      }

      # if rho is null use small positive number to emphasize the difference between
      # successive characteristic points
      if(is.null(rhoIndex))
      {
        assert(!is.null(epsilon), "Epslion parameter cannot be null if rhoIndex is null as well.")
        # epsilon should be mutiplied by -1 in order to use "<=" direction in constraint
        rhs <- -epsilon
      }

      constraints <- combineConstraints(constraints,
                                        list(lhs = lhs,
                                             dir = "<=",
                                             rhs = rhs,
                                             constraints.labels = paste("mono_", k, "_", k+1, sep="")))
    }
  }
  constraints
}

intensitiesConstraints <- function(problem, model, typeOfRelation){
  assert(typeOfRelation %in% c("strong", "weak", "indifference"),
         paste("typeOfRelation", typeOfRelation, "is not valid. Valid types of intensities are: strong, weak, indifference"))
  availableMethods <- getAvailableMethods()
  assert(model$methodName == availableMethods$roruta, paste("So far, only the `", availableMethods$roruta ,"` method supports intensities relation."))

  constraints <- list()
  relationsMatrix <- NULL
  if(typeOfRelation == "strong"){
    relationsMatrix <- problem$strongIntensitiesPreferences
  } else if(typeOfRelation == "weak") {
    relationsMatrix <- problem$weakIntensitiesPreferences
  } else if(typeOfRelation == "indifference") {
    relationsMatrix <-problem$indifferenceIntensitiesRelations
  }

  if (is.matrix(relationsMatrix)) {
    for (k in seq_len(nrow(relationsMatrix))) {
      alternatives <- relationsMatrix[k, c(1,2)]
      referenceAlternatives <- relationsMatrix[k, c(3,4)]
      constraints <- combineConstraints(constraints,
                                        buildPairwiseComparisonConstraint(alternatives, referenceAlternatives,
                                                                          model, preferenceType = typeOfRelation))

    }
  }
  constraints
}

pairwisePreferenceConstraints <- function(problem, model, typeOfPreference){
  assert(typeOfPreference %in% c("strong", "weak", "indifference"),
         paste("typeOfPreference", typeOfPreference, "is not valid. Valid types of pairwise preferences are: strong, weak, indifference"))

  preferenceMatrix <- matrix()
  if(typeOfPreference == "strong")
  {
    preferenceMatrix <- problem$strongPreferences
  } else if(typeOfPreference == "weak") {
    preferenceMatrix <- problem$weakPreferences
  } else if(typeOfPreference == "indifference") {
    preferenceMatrix <- problem$indifferenceRelations
  } else {
    return(list())
  }
  constraints <- list()

  if (is.matrix(preferenceMatrix)) {
    for (k in seq_len(nrow(preferenceMatrix))) {
      alternative <- preferenceMatrix[k, 1]
      referenceAlternative <- preferenceMatrix[k, 2]
      constraints <- combineConstraints(constraints,
                                        buildPairwiseComparisonConstraint(alternative, referenceAlternative,
                                                                          model, preferenceType = typeOfPreference))

    }
  }
  constraints
}

calculateCoefficientsMatrix <- function(problem){
  numberOfColumns <- sum(problem$characteristicPoints)
  numberOfAlternatives <- nrow(problem$performance)
  numberOfCriteria <- ncol(problem$performance)

  characteristicPointsValues <- replicate(numberOfCriteria, c())
  coefficientsMatrix.colnames <- c()
  for(j in seq_len(numberOfCriteria))
  {
    minV <- min(problem$performance[,j])
    maxV <- max(problem$performance[,j])
    characteristicPointsValues[[j]] <- seq(minV, maxV, length.out = problem$characteristicPoints[j])
    coefficientsMatrix.colnames <- c(coefficientsMatrix.colnames, paste("x_", j, "_", 1:problem$characteristicPoints[j], sep=""))
  }

  coefficientsMatrix <- matrix(0, nrow=numberOfAlternatives, ncol=numberOfColumns)
  colnames(coefficientsMatrix) <- coefficientsMatrix.colnames
  rownames(coefficientsMatrix) <- rownames(problem$performanceTable)
  thresholds <- c("lower", "upper")

  for(criterion in seq_len(numberOfCriteria)){
    characteristicPoints <- characteristicPointsValues[[criterion]]
    interval <- characteristicPoints[2] - characteristicPoints[1]
    for(alternative in seq_len(numberOfAlternatives)){
      value <- problem$performance[alternative, criterion]
      for(threshold in thresholds){
        thresholdResult <- getCharacteristicPointValueAndIndex(value, threshold, characteristicPoints)
        alternativeCoefficient <- calculateCoefficient(value, thresholdResult$value, interval)
        criterionIndex <- problem$criteriaIndices[criterion] + (thresholdResult$index - 1 )

        coefficientsMatrix[alternative,  criterionIndex] <- alternativeCoefficient
      }
    }
  }

  coefficientsMatrix
}

getCharacteristicPointValueAndIndex <- function(value, typeOfBoundToFind, characteristicPoints){
  assert(typeOfBoundToFind %in% c("lower", "upper"), "Type to find should be one of the following: `lower`, `upper`.")
  assert(length(characteristicPoints) > 1, "There must be at least 2 characteristic points!")
  #lower and upper value must be lower than at least one element and greater than at least one element
  foundValue <- NULL

  if(typeOfBoundToFind == "upper" && value == max(characteristicPoints))
  {
    foundValue <- value
  } else if(typeOfBoundToFind == "lower" && value == min(characteristicPoints))
  {
    foundValue <- value
  } else {
    for(x in characteristicPoints){
      if(typeOfBoundToFind == "lower" && value > x) {
        foundValue <- x
      } else if(typeOfBoundToFind == "upper" && value < x){
        foundValue <- x
        break
      }
    }
  }

  if(is.null(foundValue))
    return(NULL)

  index <- match(foundValue, characteristicPoints)
  if(index > 0)
  {
    return(list(index=index, value=foundValue))
  }
  return(NULL)
}

calculateCoefficient <- function(value, thresholdValue, interval){
  distance <- thresholdValue - value
  #hack, avoid rounding numerical error that are lesser than the additionalEpsilon
  #they happen when alternative's value is at characteristic point
  additionalEpsilon <- 1e-9
  assert(abs(distance) <= interval + additionalEpsilon, "Distance between value and threshold cannot be higher then the interval.")
  1 - (abs(distance)/interval)
}

getLowerAndUpperValuesCoefficients <- function(value, minimalValue, intervalLength, direction, characteristicPointIndex){
  assert(direction %in% c("c", "g"), "Direction must be of type `c` or `g`.")

  #get the bounds of this chunk
  lowerValue = minimalValue + intervalLength * characteristicPointIndex
  upperValue = minimalValue + intervalLength * (characteristicPointIndex + 1)

  assert(value >= lowerValue && value <= upperValue, 'Value cannot be neither lower than lowerValue nor higher than upperValue')

  lowerValueCoeff <- if (value == lowerValue) 1.0 else 0.0
  upperValueCoeff <- if (value == upperValue) 1.0 else 0.0

  if(direction == "g") {
    #gain type
    #find the coefficients for the lower and upper bounds
    #U(value) = U(lowerValue) + (value-lowerValue)/(upperValue-lowerValue)*(U(upperValue)-U(lowerValue))=
    # = (value-lowerValue)/(upperValue-lowerValue)
    lowerValueCoeff = (lowerValue - value) / intervalLength + 1.0
    upperValueCoeff = (value - lowerValue) / intervalLength
  } else {
    #cost type
    lowerValueCoeff = (upperValue - value) / intervalLength
    upperValueCoeff = (value - upperValue) / intervalLength + 1.0
  }
  return(list(lowerValueCoeff=lowerValueCoeff, upperValueCoeff=upperValueCoeff))
}

getInterpolationCoefficients <- function(value, minimalValue, intervalLength){
  coeff <- (value - minimalValue)/intervalLength
  return(list(lowerCoefficient = 1-coeff, upperCoefficient = coeff))
}

#substractZeroCoefficients:
# TRUE == remove one column that responds for the characteristic point that has the worst value == 0
# FALSE == don't remve this column
getCriteriaIndices <- function(problem, substractZeroCoefficients){
  criteriaIndices <- c(1)
  zeroCoefficientsToSubstract <- if(substractZeroCoefficients) 1 else 0
  for(i in seq_len(ncol(problem$performance)-1))
  {
    criteriaIndices[i+1] <- criteriaIndices[i] + problem$characteristicPoints[i] - zeroCoefficientsToSubstract
  }
  criteriaIndices
}

substractUtilityValuesOfAlternatives <- function(alternativeIndex, referenceAlternativeIndex, model){
  # it returns U(referenceAlternative) - U(alternative)
  # alternativeIndex P referenceAlternativeIndex
  model$preferencesToModelVariables[referenceAlternativeIndex,] - model$preferencesToModelVariables[alternativeIndex, ]
}

buildPairwiseComparisonConstraint <- function(alternativeIndex, referenceAlternativeIndex, model, preferenceType) {
  # TODO test for that assert
  assert(preferenceType %in% c("strong", "weak", "indifference", "necessary", "possible"),
         paste("preferenceType", preferenceType, "is not valid. Valid values are: strong, weak, indifference, necessary, possible"))
  # TODO test for that assert
  assert(length(alternativeIndex) == length(referenceAlternativeIndex),
         paste("alternativeIndex (size=",length(alternativeIndex),") must be a vector of the same size as refernceAlternativeIndex (size=",length(referenceAlternativeIndex),")", sep=""))
  # TODO test for that assert
  assert(length(alternativeIndex) == 1 || length(alternativeIndex) == 2,
         paste("Relations arity must be equal 1 or 2, got", length(alternativeIndex),".", sep=""))

  isIntensityRelation <- length(alternativeIndex) == 2

  marginalValuesVariables <- c()
  if(isIntensityRelation){
    # -a + b + (-d + c)
    marginalValuesVariables <- substractUtilityValuesOfAlternatives(alternativeIndex[1], alternativeIndex[2], model) +
      substractUtilityValuesOfAlternatives(referenceAlternativeIndex[1], referenceAlternativeIndex[2], model)
  } else {
    marginalValuesVariables <- substractUtilityValuesOfAlternatives(alternativeIndex, referenceAlternativeIndex, model)
  }
  # lhs holds a vector of a length equal to the number of marginal values
  # lhs should be a vector of the length of a number of columns in constraints matrix
  lhs <- rep(0, ncol(model$constraints$lhs))
  lhs[0:length(marginalValuesVariables)] <- marginalValuesVariables

  dir <- "<="
  rhs <- 0

  if (preferenceType == "strong") {
    if (!is.null(model$kIndex)) {
      lhs[model$kIndex] <- 1
    } else {
      assert(!is.null(model$minEpsilon), "Model has not an epsilon and minEpsilon is not set.")
      rhs <- -model$minEpsilon
    }
  } else if (preferenceType == "indifference") {
    dir <- "=="
  } else if (preferenceType == "necessary") {
    dir <- ">="
    lhs[model$epsilonIndex] <- -1
  } else if (preferenceType == "possible") {
    # U(a) - U(b) >= 0 <==> U(b) - U(a) <= 0
    # do nothing
  }

  # use collapse parameter in case of intensity type constraints
  constraints.labels.alternative <- paste(alternativeIndex, collapse = ",")
  constraints.labels.refAlternative <- paste(referenceAlternativeIndex, collapse = ",")

  # substr(preferenceType, 1, 3)
  constraints.labels <- paste(preferenceType, "_rel_", constraints.labels.alternative, "_", constraints.labels.refAlternative, sep="")

  return (list(lhs = lhs, dir = dir, rhs = rhs, constraints.labels = constraints.labels))
}
# TODO add combining decision variables names
combineConstraints <- function(...) {
  allConst <- list(...)

  lhs <- c()
  dir <- c()
  rhs <- c()
  variablesTypes <- c()
  constraints.labels <-c()

  for (const in allConst) {
    if (!is.null(const)) {
      lhs <- rbind(lhs, const$lhs)
      dir <- c(dir, const$dir)
      rhs <- c(rhs, const$rhs)
      variablesTypes <- c(variablesTypes, const$variablesTypes)
      constraints.labels <- c(constraints.labels, const$constraints.labels)
    }
  }

  return (list(lhs = lhs, dir = dir, rhs = rhs, variablesTypes = variablesTypes, constraints.labels = constraints.labels))
}

ua <- function(alternative, preferencesToModelVariables) {
  preferencesToModelVariables[alternative,]
}

removeColumnsFromModelConstraints <- function(model, columnsIndices){
  assert(ncol(model$constraints$lhs) >= max(columnsIndices),
         paste("Cannot remove a column with index", max(columnsIndices), ", LHS contains only", ncol(model$constraints$lhs)))
  if(length(columnsIndices) < 1){
    return(model)
  }
  sortedColumnsIndices <- sort(columnsIndices)
  lhs <- model$constraints$lhs[, -sortedColumnsIndices]
  variablesTypes <- model$constraints$variablesTypes[-sortedColumnsIndices]

  # remove columns from the model$preferencesToModel if appropriate columns were indicated
  preferencesIndicesToRemove <- sortedColumnsIndices[sortedColumnsIndices < ncol(model$preferencesToModelVariables)]
  preferencesToModelVariables <- model$preferencesToModelVariables
  if(length(preferencesIndicesToRemove) > 0){
    preferencesToModelVariables <- model$preferencesToModelVariables[, -preferencesIndicesToRemove]
  }

  # if the columnIndex is equal to the of the additional variables then remove it
  rhoIndex <- if(model$rhoIndex %in% sortedColumnsIndices) NULL else model$rhoIndex
  kIndex <- if(model$kIndex %in% sortedColumnsIndices) NULL else model$kIndex

  # otherwise move its position in the constraints matrix to the left (decrease its index)
  if(!is.null(rhoIndex)){
    positionToMove <- length(sortedColumnsIndices[sortedColumnsIndices < rhoIndex])
    rhoIndex <- rhoIndex - positionToMove
  }

  if(!is.null(kIndex)){
    positionToMove <- length(sortedColumnsIndices[sortedColumnsIndices < kIndex])
    kIndex <- kIndex - positionToMove
  }

  constraints <- list(lhs = lhs,
                     rhs = model$constraints$rhs,
                     dir = model$constraints$dir,
                     variablesTypes = variablesTypes,
                     constraints.labels = model$constraints$constraints.labels)

  # return a new model
  list(
    constraints = constraints,
    criteriaIndices = model$criteriaIndices,
    rhoIndex = rhoIndex,
    kIndex = kIndex,
    chPoints = model$chPoints,
    preferencesToModelVariables = preferencesToModelVariables,
    criterionPreferenceDirection = model$criterionPreferenceDirection,
    generalVF = model$generalVF,
    minEpsilon = model$minEpsilon,
    methodName = model$methodName,
    performances = model$performance
  )
}

splitVariable <- function(model, variableIndex, variableName){
  colsInConstraints <- ncol(model$constraints$lhs)

  # find all indices of constraints where variableIndex is enabled <==> 1
  constraintsRowsWithVariable <- which(model$constraints$lhs[, variableIndex] %in% 1)
  constraints <- model$constraints

  if(length(constraintsRowsWithVariable) > 0) {
    # there are some constraints with the variableIndex enabled

    # add as many columns as the number of indices found
    constraints$lhs <- cbind(constraints$lhs, matrix(0, nrow = nrow(constraints$lhs), ncol = length(constraintsRowsWithVariable)))

    # for all constraints where the variableIndex is enabled
    columnsIterator <- colsInConstraints + 1
    for(i in constraintsRowsWithVariable){
      # disable variableIndex index in constraint
      constraints$lhs[i, variableIndex] <- 0

      # add partial variable constraint
      constraints$lhs[i, columnsIterator] <- 1

      # add constraint row: partialVariable >= variable <=> variable - partialVariable <= 0
      lhs = rep(0, ncol(constraints$lhs))

      # variable
      lhs[variableIndex] <- 1
      # -partialVariable
      lhs[columnsIterator] <- -1

      constraint <- list(lhs = lhs, dir = "<=", rhs = 0, constraints.labels = paste(variableName, "_i<", variableName, sep=""))
      # add new constraint: partialVariable >= variable
      constraints <- combineConstraints(constraints, constraint)

      columnsIterator <- columnsIterator + 1
    }

    # all variables are of a continous type
    constraints$variablesTypes <- rep("C", ncol(constraints$lhs))
  }
  # return new constraints
  constraints
}
